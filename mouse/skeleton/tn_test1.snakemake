#################################
#
# snakefile for converting CIDR Sequencing data deliveries to non-PII ready for GRIS upload, running QC, and joint genotyping
#
# Susan Huse, susan.huse@nih.gov
# Frederick National Lab
# April 10, 2019
#
# Justin Lack
# Frederick National Lab
# December 11, 2019
#
# Mayank Tandon
# Frederick National Lab
# Feb, 2021
#
#################################
##### To dos:
## -- finish converting rules to not contain file paths (wherever possible)
## -- update cluster.json with appropriate settings for new rules!!
## -- Add more input/output path settings via config
## - should help with start-from-bam
## - will it work for adding arbirary vcfs (like from dragen)?
## -- GATK4 pre-processing
## -- Split all callers by chromosome?
## -- integrate into python-driven workflow like Skyler's RNA-Seek repo: https://github.com/skchronicles/RNA-seek/blob/main/rna-seek
## -- use containerized gatk4 via snakemake (require converting docker to singularity) https://github.com/skchronicles/RNA-seek/blob/7e2db2d4897e8c7a2c5cc5bba88c94fb63b5e642/workflow/rules/paired-end.smk#L25
## -- Use 'envmodules' to module load
## -- 
## ++ Purity estimates (--PureCN?--  > GATK4 CalculateContamination)
## - Ideally use same tool for tumor-normal or tumor-only
## - Can be additionally useful for passing to somatic variant valler (VarScan, e.g.)
## -- use nproc instead of biowulf cpus variable
## -- use nproc instead of biowulf cpus variable
## ++ VarScan
## ++ use containerized vcf2maf
##### 
## 
## Load python modules
##
import os
from os import listdir
# from os.path import join
import pandas as pd
import re
import sys
import glob
import datetime

## FROM: https://github.com/skchronicles/RNA-seek/blob/main/rna-seek
def rename(filename):
    """Dynamically renames FastQ file to have one of the following extensions: *.R1.fastq.gz, *.R2.fastq.gz
    To automatically rename the fastq files, a few assumptions are made. If the extension of the
    FastQ file cannot be infered, an exception is raised telling the user to fix the filename
    of the fastq files.
    @param filename <str>:
        Original name of file to be renamed
    @return filename <str>:
        A renamed FastQ filename
    """
    import re

    # Covers common extensions from SF, SRA, EBI, TCGA, and external sequencing providers
    # key = regex to match string and value = how it will be renamed
    extensions = {
        # Matches: _S[##]_R[12]_fastq.gz, _S[##]_R[12].fastq.gz, _R[12]_fq.gz; works for exome fqs from SF
        "_S[0-9]+_R1_001.f(ast)?q.gz$": ".R1.fastq.gz",
        "_S[0-9]+_R2_001.f(ast)?q.gz$": ".R2.fastq.gz",
        # Matches: _R[12]_fastq.gz, _R[12].fastq.gz, _R[12]_fq.gz, etc.
        ".R1.f(ast)?q.gz$": ".R1.fastq.gz",
        ".R2.f(ast)?q.gz$": ".R2.fastq.gz",
        # Matches: _R[12]_001_fastq_gz, _R[12].001.fastq.gz, _R[12]_001.fq.gz, etc.
        # Capture lane information as named group
        ".R1.(?P<lane>...).f(ast)?q.gz$": ".R1.fastq.gz",
        ".R2.(?P<lane>...).f(ast)?q.gz$": ".R2.fastq.gz",
        # Matches: _[12].fastq.gz, _[12].fq.gz, _[12]_fastq_gz, etc.
        "_1.f(ast)?q.gz$": ".R1.fastq.gz",
        "_2.f(ast)?q.gz$": ".R2.fastq.gz",
        ####
        # Matches: *.bam if it's not preceded by '.recal' (i.e. match '.recal.bam' exactly)
        "(?<!\.recal)\.bam$": ".recal.bam",
        "\.recal\.bam$": ".recal.bam"
    }

    if filename.endswith('.R1.fastq.gz') or filename.endswith('.R2.fastq.gz'):
        # Filename is already in the correct format
        return filename

    converted = False
    for regex, new_ext in extensions.items():
        matched = re.search(regex, filename)
        if matched:
            # regex matches with a pattern in extensions
            converted = True
            # Try to get substring for named group lane, retain this in new file extension
            # Come back to this later, I am not sure if this is necessary
            # That string maybe static (i.e. always the same)
            # https://support.illumina.com/help/BaseSpace_OLH_009008/Content/Source/Informatics/BS/NamingConvention_FASTQ-files-swBS.htm#
            try: new_ext = "_{}{}".format(matched.group('lane'), new_ext)
            except IndexError: pass # Does not contain the named group lane

            filename = re.sub(regex, new_ext, filename)
            break # only rename once

    if not converted:
        raise NameError("""\n\tFatal: Failed to rename provided input '{}'!
        Cannot determine the extension of the user provided input file.
        Please rename the file list above before trying again.
        Here is example of acceptable input file extensions:
          sampleName.R1.fastq.gz      sampleName.R2.fastq.gz
          sampleName_R1_001.fastq.gz  sampleName_R1_001.fastq.gz
          sampleName_1.fastq.gz       sampleName_2.fastq.gz
        Please also check that your input files are gzipped?
        If they are not, please gzip them before proceeding again.
        """.format(filename, sys.argv[0])
        )

    return filename

## FROM: https://github.com/skchronicles/RNA-seek/blob/main/rna-seek
def _sym_safe_(input_data, target):
    """Creates re-named symlinks for each FastQ file provided
    as input. If a symlink already exists, it will not try to create a new symlink.
    If relative source PATH is provided, it will be converted to an absolute PATH.
    @param input_data <list[<str>]>:
        List of input files to symlink to target location
    @param target <str>:
        Target path to copy templates and required resources
    @return input_fastqs list[<str>]:
        List of renamed input FastQs
    """
    input_fastqs = [] # store renamed fastq file names
    for file in input_data:
        filename = os.path.basename(file)
        renamed = os.path.join(target, rename(filename))
        input_fastqs.append(renamed)

        if not os.path.exists(renamed):
            # Create a symlink if it does not already exist
            # Follow source symlinks to resolve any binding issues
            os.symlink(os.path.abspath(os.path.realpath(file)), renamed)

    return input_fastqs

def read_pairsfile(pairs_filepath):
    ## Could add more error-checking here; file access, header names,...
    if not os.path.isfile(pairs_filepath):
        raise NameError("""\n\tFatal: A pairs file is required!
        This is the path that was given in the config: {}
        """.format(pairs_filepath, sys.argv[0])
        )
    df = pd.read_csv(pairs_filepath, header=0, sep='\t')
    mydict = dict(zip(df['Tumor'].tolist(), df['Normal'].tolist()))
    return mydict

configfile:"references_mm10.json"

######### PARSE INPUTS #########
#print(listdir(os.getcwd()))
pairs_file = config['input_params']['PAIRS_FILE']
pairs_dict = read_pairsfile(pairs_file)
pairs_ids=list(pairs_dict.keys())

######### PARSE CONFIG PARAMS #########
BASEDIR=os.path.realpath(config['input_params']['BASE_OUTDIR'])
input_fqdir=config['input_params']['FASTQ_SOURCE']
fqs_found=glob.glob(os.path.join(input_fqdir,'*.fastq.gz'))

input_bamdir=os.path.join(config['input_params']['BAM_SOURCE'])
bams_found=glob.glob(os.path.join(input_bamdir,'*.bam'))

output_fqdir=os.path.join(BASEDIR,config['output_params']['FASTQ'])
output_bamdir=os.path.join(BASEDIR,config['output_params']['BAM'])


name_symlinks=[]
if fqs_found:
    name_suffix=".R[1,2].fastq.gz"
    if not os.path.exists(output_fqdir):
        # print("making"+output_fqdir)
        os.makedirs(output_fqdir) 
        name_symlinks=_sym_safe_(fqs_found, output_fqdir)
    else:
        name_symlinks=glob.glob(os.path.join(output_fqdir,'*.fastq.gz'))
elif bams_found:
    name_suffix=".recal.bam"
    if not os.path.exists(output_bamdir):
        os.makedirs(output_bamdir) 
    if (len(os.listdir(output_bamdir))==0):
        bam_symlinks=_sym_safe_(bams_found, output_bamdir)
    name_symlinks=glob.glob(os.path.join(output_bamdir,'*.recal.bam'))
else:
    raise NameError("""\n\tFatal: No relevant files found in the BAM or FASTQ directory!
        FASTQ source path provided: {}
        BAM source path provided: {}
        Folders should contain files ending with '.fastq.gz' or '.bam' respectively.
        """.format(input_fqdir, input_bamdir, sys.argv[0])
    )

samples = set([re.sub(name_suffix,"",os.path.basename(fname)) for fname in name_symlinks]) ## Only returns paired fqs

output_germline_base=os.path.join(BASEDIR,"germline")
output_somatic_base=os.path.join(BASEDIR,"somatic")
output_somatic_snpindels=os.path.join(output_somatic_base,"SNP_Indels")
output_somatic_cnv=os.path.join(output_somatic_base,"CNV")

chroms = ["chr1","chr2","chr3","chr4","chr5","chr6","chr7","chr8","chr9","chr10","chr11","chr12","chr13","chr14","chr15","chr16","chr17","chr18","chr19","chrX","chrY","chrM"]
intervals_file=os.path.join(BASEDIR,"intervals.list")
if not os.path.isfile(intervals_file):
    with open(intervals_file, 'w') as f:
        f.write("\n".join(chroms))
        f.close
        
# caller_dict=config['output_params']['SOMATIC_VCF']
caller_list=[caller_name.lower() for caller_name in config['input_params']['VARIANT_CALLERS']]
caller_list=list(set(caller_list) & set(config['available_somatic_callers']))

if not caller_list:
    raise NameError("""\n\tFatal: Must define one or more variant caller!
        """.format(input_fqdir, input_bamdir, sys.argv[0])
    )

merge_outdir=config['output_params']['MERGED_SOMATIC_OUTDIR']
somatic_callers_dirs = [caller + "_out" for caller in list(caller_list)]

samples_for_caller_merge=[]
merge_callers_args=dict.fromkeys(pairs_ids)
merge_callers_rodlist=",".join(caller_list)
if (len(caller_list) > 1):
    merge_callers_args_list = [["--variant:{} {}/{}/{}.FINAL.vcf".format(re.sub("_out","",vc_out), os.path.join(output_somatic_snpindels, vc_out),"vcf",pair_id) for vc_out in somatic_callers_dirs] for pair_id in pairs_ids]
    merge_callers_args = dict(zip(pairs_ids, [" ".join(arglist) for arglist in merge_callers_args_list]))
    samples_for_caller_merge=pairs_ids
    somatic_callers_dirs=list(somatic_callers_dirs + [merge_outdir])


VCF2MAF_WRAPPER=config['scripts']['vcf2maf_wrapper']
SOBDetector_out=os.path.join(output_somatic_base,"ffpe_filter","sobdetector")
SOBDetector_JARFILE=os.path.join(SOBDetector_out, "jarfile","SOBDetector_v1.0.2.jar")

exome_targets_bed=config['input_params']['EXOME_TARGETS']

ffpe_caller_list=[]
ffpe_sample_list=[]
if 'FFPE_FILTER' in config['input_params']:
    if config['input_params']['FFPE_FILTER'].lower() in ['true','t','yes']:
        ffpe_caller_list=somatic_callers_dirs
        ffpe_sample_list=pairs_ids
    
  
cnv_sample_list=[]
if 'CNV_CALLING' in config['input_params']:
    if config['input_params']['CNV_CALLING'].lower() in ['true','t','yes']:
        cnv_sample_list=pairs_ids    
    
# print(somatic_callers_dirs)
# print(samples_for_caller_merge)
# print(config['input_params']['FFPE_FILTER'].lower() )
# print(ffpe_caller_list)
# print(len(caller_list))
# # print(pairs_dict)
# print(merge_callers_args)
# exit()
#
# Set rule all
#
rule all:
    input:
        expand(os.path.join(output_bamdir,"{samples}.recal.bam"), samples=samples),
        expand(os.path.join(output_bamdir,"{samples}.recal.bai"), samples=samples),
  
        # os.path.join(merge_outdir,"maf","merged_oncoplot.pdf"),
        # os.path.join("mutect_out","maf","mutect_oncoplot.pdf"),
        # os.path.join("mutect2_out","maf","mutect2_oncoplot.pdf"),
        # os.path.join("strelka_out","maf","strelka_oncoplot.pdf"),
        # expand(os.path.join("superfreq","vcfs","{samples}.allRaw.vcf"), samplespairs_ids),
        # expand(os.path.join("pyclone","{samples}","config.yaml"), samplespairs_ids),
        # expand("HLA/{samplesb}/hla/R1_bestguess_G.txt", samplesb=samplesb),

rule trimmomatic:
    input:  r1=os.path.join(input_fqdir, "{samples}.R1.fastq.gz"),
            r2=os.path.join(input_fqdir, "{samples}.R2.fastq.gz")
    output: one=temp(os.path.join(output_fqdir,"{samples}.R1.trimmed.fastq.gz")),
            two=temp(os.path.join(output_fqdir,"{samples}.R1.trimmed.unpair.fastq.gz")),
            three=temp(os.path.join(output_fqdir,"{samples}.R2.trimmed.fastq.gz")),
            four=temp(os.path.join(output_fqdir,"{samples}.R2.trimmed.unpair.fastq.gz")),
            err=os.path.join(output_fqdir,"{samples}_run_trimmomatic.err")
    params: adapterfile=config['references']['trimmomatic.adapters'],ver=config['tool_versions']['trimmomatic'],rname="pl:trimmomatic"
    # threads: 32
    shell:  """
            module load trimmomatic/{params.ver};
            myoutdir="$(dirname {output.one})"
            if [ ! -d "$myoutdir" ]; then mkdir -p "$myoutdir"; fi
            
            trimmomatic PE -threads $((SLURM_CPUS_PER_TASK-1)) -phred33 {input.r1} {input.r2} {output.one} {output.two} {output.three} {output.four} ILLUMINACLIP:{params.adapterfile}:3:30:10 LEADING:10 TRAILING:10 SLIDINGWINDOW:4:20 MINLEN:20 2> {output.err}
            
            """

rule bwa_mem:
    input:  os.path.join(output_fqdir,"{samples}.R1.trimmed.fastq.gz"),
            os.path.join(output_fqdir,"{samples}.R2.trimmed.fastq.gz")
    output: temp(os.path.join(output_bamdir,"{samples}.raw_map.bam"))
    params: genome=config['references']['GENOME'],sample = "{samples}",ver_samtools=config['tool_versions']['samtools'],ver_bwa=config['tool_versions']['bwa'],rname="pl:bwamem"
    # threads: 32
    shell:  """
            module load samtools/{params.ver_samtools}
            module load bwa/{params.ver_bwa}
            myoutdir="$(dirname {output})"
            if [ ! -d "$myoutdir" ]; then mkdir -p "$myoutdir"; fi
            bwa mem -M -R \'@RG\\tID:{params.sample}\\tSM:{params.sample}\\tPL:illumina\\tLB:{params.sample}\\tPU:{params.sample}\\tCN:hgsc\\tDS:wes\' -t $((SLURM_CPUS_PER_TASK-1)) {params.genome} {input} | /usr/local/apps/samblaster/0.1.25/bin/samblaster -M | samtools sort -@12 -m 4G - -o {output}
            """

rule raw_index:
      input:  bam=os.path.join(output_bamdir,"{samples}.raw_map.bam")
      output: bai=temp(os.path.join(output_bamdir,"{samples}.raw_map.bai")),
      params: ver_samtools=config['tool_versions']['samtools'],rname="index"
      shell:  """
              module load samtools/{params.ver_samtools}
              samtools index -@ 2 {input.bam} {output.bai}
              """
rule realign:
      input:  bam=os.path.join(output_bamdir,"{samples}.raw_map.bam"),
              bai=os.path.join(output_bamdir,"{samples}.raw_map.bai"),
      output: bam=temp(os.path.join(output_bamdir,"{samples}.realign.bam")),
              int=temp(os.path.join(output_bamdir,"{samples}.intervals")),
      params: genome=config['references']['GENOME'],knowns=config['references']['KNOWNINDELS'],ver_gatk=config['tool_versions']['gatk3'],rname="realign"
      shell:  """
              module load GATK/{params.ver_gatk}
              java -Xmx48g -jar $GATK_JAR -T RealignerTargetCreator -I {input.bam} -R {params.genome} -o {output.int} {params.knowns}
              java -Xmx48g -jar $GATK_JAR -T IndelRealigner -R {params.genome} -I {input.bam} {params.knowns} --use_jdk_inflater --use_jdk_deflater -targetIntervals {output.int} -o {output.bam}
              """


rule gatk_recal:
      input:  os.path.join(output_bamdir,"{samples}.realign.bam")
      output: bam=os.path.join(output_bamdir,"{samples}.recal.bam"),
              re=temp(os.path.join(output_bamdir,"{samples}_recal_data.grp"))
      params: genome=config['references']['GENOME'],knowns=config['references']['KNOWNRECAL'],ver_gatk=config['tool_versions']['gatk4'],rname="recal"
      threads: 24
      shell:  """
              module load GATK/{params.ver_gatk}
              gatk --java-options '-Xmx48g' BaseRecalibrator --input {input} --reference {params.genome} {params.knowns} --output {output.re}
              gatk --java-options '-Xmx48g' ApplyBQSR --reference {params.genome} --input {input} --bqsr-recal-file {output.re} --output {output.bam} --use-jdk-inflater --use-jdk-deflater
              """

rule bam_index:
      input:  bam=os.path.join(output_bamdir,"{samples}.recal.bam")
      output: bai=os.path.join(output_bamdir,"{samples}.recal.bai"),
              bai2=os.path.join(output_bamdir,"{samples}.recal.bam.bai"),
      params: ver_samtools=config['tool_versions']['samtools'],rname="index"
      shell:  """
              module load samtools/{params.ver_samtools}
              samtools index -@ 2 {input.bam} {output.bai}
              cp {output.bai} {output.bai2}
              """
